// STL 에서 함수객체 사용하기

// 백터를 출력해 봅시다. 
// for_each 함수     
//      반복자 순서에 맞게 각 맴버를 순차적으로 전달받아 처리함, 
//      어떤 일을 할지 함수(Callable)를 전달하면 됨. 

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void print1(int a)      //function -> 함수포인터
{
    printf("%d\n", a);
}

struct print2           //class -> 함수 객체
{
    void operator()(int a) const {
        printf("%d\n", a);
    }
};

void main()
{
    int ar[] = { 2,8,5,1,9 };
    vector<int> v(&ar[0], &ar[5]);              //배열을 벡터로 변환 //주소 전달
    //vector<int> v(ar, ar + sizeof(ar)/ sizeof(int));

    sort(v.begin(), v.end());

    for_each(v.begin(), v.end(), print1);       //함수포인터 //C
    
    for_each(v.begin(), v.end(), print2());     //함수 객체 //C++

    //for_each는 반복자 순서에 맞게 순회만 할 뿐이며, 실제 작업은 함수 객체가 한다
}


//for_each 함수의 세 번째 인수로 전달된 대상을 
//    '함수 객체(Function Object)' 또는 '펑크터(Functor)' 라고 한다.

//함수 객체는 
//    함수 호출 연산자인()를 오버로딩한 객체를 의미하는데 
//    이 연산자를 통해 마치 함수를 호출하듯이 객체를 호출할 수 있다.
//    함수 객체는 클래스 안에 함수를 캡슐화 해 놓은 것으로 함수 포인터에 대한 일반화라고 할 수 있다.


//STL이 함수 포인터를 확장하여 함수 객체라는 더 일반화된 개념을 사용하는 '이유'는 
//    함수 포인터에 비해 몇 가지 장점이 있고 더 유연하기 때문이다.
//
//    함수 객체는 인라인이 가능해서 '처리 속도'를 대폭적으로 개선할 수 있다.
//    클래스 내부에 선언된 멤버 함수는 자동으로 인라인이 되며 호출부에 본체의 코드가 직접 삽입된다.
//    그래서 함수 호출에 대한 부담이 전혀 없으며 알고리즘 처리가 빠르다.
//
//    객체이기 때문에 함수 연산자()뿐만 아니라 처리에 '필요한 멤버들을 추가'로 더 가질 수도 있다.
//    연산 중에 필요한 변수가 있으면 멤버로 만들 수 있고 필요한 동작이 있다면 멤버 함수도 가질 수 있다.


//STL의 함수는 함수 포인터에만 국한되는 것이 아니라 '함수를 흉내낼 수 있는 모든 객체'일 수 있다
//    함수 포인터, 함수 객체, 람다
