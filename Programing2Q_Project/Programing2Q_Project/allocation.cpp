//C++은 세 가지 기본 타입의 메모리 할당을 지원한다.

//자동 메모리 할당(auto memory allocation)은
//		함수 매개 변수와 지역 변수에 대해 발생한다.
//		이러한 타입의 변수에 대한 메모리는 관련 블록을 입력할 때 할당되고, 블록을 종료할 때 필요에 따라 여러 번 해제된다.

//정적 메모리 할당(static memory allocation)은
//		정적 변수와 전역변수에 대해 발생한다.
//		이러한 타입의 변수에 대한 메모리는 프로그램이 실행될 때 한 번 할당되며, 프로그램 수명 내내 지속한다.

//동적 메모리 할당(dynamic memory allocation)은
//		프로그램 실행 중에 필요한 메모리를 운영체제에 요청하는 방법이다.


//정적 및 자동 메모리 할당의 한계
// 
//		메모리 할당 및 해제가 자동으로 수행된다. (변수가 인스턴스화 / 제거되는 경우)
//		변수 / 배열의 크기는 컴파일 타임에 알아야 한다.
//
//		낭비되는 메모리가 많다
//		스택(stack)이라는 메모리 영역에 할당
//		인위적인 한계 및 또는 배열 오버플로가 발생할 수 있다
//
//동적 메모리 할당(dynamic memory allocation) 으로 해결.

//#include <iostream>
//
//int main()
//{
//	//운영 체제에서 정수값의 메모리를 요청한다. 
//	//new 연산자는 해당 메모리를 사용하여 객체를 만든 다음 할당된 메모리의 주소가 포함된 포인터를 반환한다.
//	int* ptr = new int;
//
//	//포인터를 역참조(dereference)하여 메모리에 접근할 수 있다.
//	*ptr = 7;
//
//	//방금 할당된 메모리의 주소를 유지하는 포인터가 없으면 할당된 메모리에 접근할 수 없다.
//
//	//메모리를 해제하여 재사용할 수 있도록 C++에 명시적으로 알려야 한다.
//	delete ptr;
//
//	//delete 연산자는 실제로 아무것도 삭제하지 않는다. ***
//	//단순히 가리키는 메모리를 다신 운영 체제로 반환한다.
//
//	//동적으로 할당된 메모리를 가리키지 않는 포인터를 삭제하면 에러가 발생할 수 있다. ***
//	delete ptr;		// 운영체제에 돌려준 공간 침범 //여러번 delete 하면 안됨
//
//	return 0;
//}

//댕글링 포인터 (Dangling pointers) ------------------------------------------------------------
//
//	C++은 할당되지 않은 메모리의 내용이나 삭제되는 포인터의 값에 대해서는 보장하지 않는다.
// 
//	운영 체제에 반환되는 메모리에는 
//  반환되기 전의 값과 같은 값이 포함되며, 포인터는 현재 할당 해제된 메모리를 가리킨다.
//	할당이 해제된 메모리를 가리키는 포인터를 '댕글링 포인터'(dangling pointer)라고 한다.
// 
//	댕글링 포인터를 역참조하거나 삭제하면 정의되지 않은 동작이 발생한다.
//
//	먼저, 여러 포인터가 같은 동적 메모리를 가리키는 것을 피하자. ***
//	둘째, 포인터를 삭제할 때 포인터를 0 또는 nullptr로 설정하자. ***

// Null pointers -----------------------------------------------------------------------------

//	동적 메모리 할당과 관련하여 널 포인터는 
//	기본적으로 "이 포인터에 메모리가 할당되지 않았다" 를 의미한다.
// 
//	이렇게 하면 조건부로 메모리를 할당하는 작업을 할 수 있다. ***
//		if (!ptr) ptr = new int;

//	널 포인터는 삭제되지 않는다. 따라서 다음과 같이 할 필요가 없다. ***
//		if (ptr) delete ptr;
//	대신, 다음과 같이 작업하면 된다.
//		delete ptr;					//ptr 이 널이 된 것은 아니다.
// 
//	ptr이 
//		nullptr 이 아닌 경우, 동적으로 할당된 변수가 삭제된다. 
//		만약 nullptr 이라면, 아무 일도 일어나지 않는다.
// 
//		ptr = nullptr;
//		delete ptr;


// 메모리 누수 (Memory leak) -----------------------------------------------------------------
//		delete 안함, 주소상실, 중복할당 등의 경우 메모리 누수 발생

//{
//	int* ptr = new int;		// delete 안함 //new int 영역은 미아
//}
//
//{
//	int value = 5;
//	int* ptr = new int;
//	ptr = &value;			// 주소상실 //old address lost, memory leak results
//}
//
//{
//	int* ptr = new int;		// allocate memory
//	cout << ptr << endl;
//	ptr = new int;			// 재할당 //기존의 new int 영역은 미아가 되버린다
//}
//
//int* ptr = nullptr;
//for (size_t i = 0; i < 10; i++) {
//	ptr = new int;	*ptr = 1;	// 재할당
//}
//delete ptr;

// Double Free ------------------------------------------------------

//int* ptr = nullptr;
//ptr = new int;
//delete ptr;
//delete ptr;		
