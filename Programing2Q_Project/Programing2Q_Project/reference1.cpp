#include <iostream>
using namespace std;

//C++
//참조자 //포인터와 다르게 변하지 않는 주소 //또하나의 이름

// 참조변수 선언 //포인터와 참조 비교하기 ---------------------------------------

//int main(void)
//{
//	int a = 0;			// int a
//	int* p = &a;		// int* p	//주소를 담는 또다른 변수		//C
//	*p = 2;
//
//	int b = 0;			// int b, r		
//	int& r = b;			// r 은 b 로 해석됨. 또 하나의 이름		//C++
//	r = 2;
//
//	//int& ref;	     	// 참조는 무조건 선언과 동시에 초기화를 해야한다
//	p = nullptr;		// 포인터는 참조하는 주소 변경 가능하다.	
//	r = a;				// 참조변수는 변경 불가. r에 a의 값을 대입하는 것이지, r이 a를 가리키는 것이 아님
//}

// 참조변수 선언 //사용, 주소 비교하기 ------------------------------------------

//int main(void)
//{
//	int num1 = 1024;
//	int& num2 = num1;			//참조변수 선언	//별명, 또하나의 이름 
//
//	num2 = 2000;				//num2로 하는 모든 연산은 num1로 하는것과 동일
//	cout << num1 << endl;
//	cout << num2 << endl;
//
//	cout << &num1 << endl;		//주소 비교하기
//	cout << &num2 << endl;		//주소 비교하기
//
//
//	//참조자의 수에는 제한이 없으며, 참조자를 대상으로 참조자를 선언하는 것도 가능
//	int& num3 = num2;
//	int& num4 = num3;
//
//
//	//일단 초기화되면 참조를 재할당할 수 없다. ***  ----------------------------
//	//		참조는 변경되는 것이 아니므로 포인터보다 안전하게 사용이 가능하다. 
//
//	num3 = num4;				//참조가 변경되는 것이 아니다. num3 에 num4의 값을 대입하는 것이다.
//
//	//참조 대상이 있어야 한다. *** --------------------------------------------
//	//int& ref;					//error
//	//int& ref = NULL;			//error		//포인터와 다르게, nullptr 참조 같은 것은 없다.
//	//int& ref = 10;				//error		//10은 상수, 주소가 없다.
//}


//변수 타입에 대해 선언이다.-----------------------------------------------------

//int main(void)
//{
//	// 배열인자도 변수 성향이므로 참조자 가능 ----------------------
//	int arr[3] = { 1, 3, 5 };
//
//	int& ref1 = arr[0];
//	int& ref2 = arr[1];
//	cout << ref1 << endl;
//	cout << ref2 << endl;
//
//	// 포인터도 변수이므로 참조자 가능 -----------------------------
//	int num = 12;
//	int* ptr = &num;
//
//	int& ref = num;
//	int*& pref = ptr;		//포인터 ptr 에 대한 참조 선언 
//	int* (&pref) = ptr;
//
//	cout << ref << endl;
//	cout << *pref << endl;	//pref는 포인터를 참조하므로 포인터.
//
//	//참조자 주소를 포인터 포인터로 가르키는 것도 가능 
//	int* rptr = &ref;		//&ref == &num
//	cout << *rptr << endl;
//
//
//	//문제) 다음 중 잘못된 표현은 ?
//	int a = 0;
//	int* p1 = &a;
//	int& r1 = a;
//	int*& p2 = p1;
//	//int&* r2 = &r1;
//
//	//int&* p = nullptr;	//error 사용할 수 없습니다.
//
//	return 0;
//}


// 컴파일러는 참조자를 메모리에 할당하지 않고, 참조자가 참조하는 변수의 alias처럼 생각한다.
// 예를 들어  int& b = a; 경우, 컴파일러는 b가 나오면 그냥 다 a로 생각하는 것이다.
// 따라서 참조자는 포인터와 다르게 메모리 주소를 가지지 않는다.
// 포인터의 경우, nullptr 인지 여부를 확인하고 사용해야 한다. 또 변경될 때 주의해야 한다.
// 참조의 경우, 참조하는 대상이 존재하는지 여부를 주의해야 한다. ***
